{"version":3,"file":"client.gen-Cs-igdZt.js","sources":["../../../Client/src/api/core/bodySerializer.gen.ts","../../../Client/src/api/core/serverSentEvents.gen.ts","../../../Client/src/api/core/pathSerializer.gen.ts","../../../Client/src/api/core/utils.gen.ts","../../../Client/src/api/core/auth.gen.ts","../../../Client/src/api/client/utils.gen.ts","../../../Client/src/api/client/client.gen.ts","../../../Client/src/api/client.gen.ts"],"sourcesContent":["// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  ArrayStyle,\n  ObjectStyle,\n  SerializerOptions,\n} from './pathSerializer.gen';\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializeFormDataPair = (\n  data: FormData,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else if (value instanceof Date) {\n    data.append(key, value.toISOString());\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n): void => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): FormData => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T): string =>\n    JSON.stringify(body, (_key, value) =>\n      typeof value === 'bigint' ? value.toString() : value,\n    ),\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ): string => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data.toString();\n  },\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { Config } from './types.gen';\n\nexport type ServerSentEventsOptions<TData = unknown> = Omit<\n  RequestInit,\n  'method'\n> &\n  Pick<Config, 'method' | 'responseTransformer' | 'responseValidator'> & {\n    /**\n     * Fetch API implementation. You can use this option to provide a custom\n     * fetch instance.\n     *\n     * @default globalThis.fetch\n     */\n    fetch?: typeof fetch;\n    /**\n     * Implementing clients can call request interceptors inside this hook.\n     */\n    onRequest?: (url: string, init: RequestInit) => Promise<Request>;\n    /**\n     * Callback invoked when a network or parsing error occurs during streaming.\n     *\n     * This option applies only if the endpoint returns a stream of events.\n     *\n     * @param error The error that occurred.\n     */\n    onSseError?: (error: unknown) => void;\n    /**\n     * Callback invoked when an event is streamed from the server.\n     *\n     * This option applies only if the endpoint returns a stream of events.\n     *\n     * @param event Event streamed from the server.\n     * @returns Nothing (void).\n     */\n    onSseEvent?: (event: StreamEvent<TData>) => void;\n    serializedBody?: RequestInit['body'];\n    /**\n     * Default retry delay in milliseconds.\n     *\n     * This option applies only if the endpoint returns a stream of events.\n     *\n     * @default 3000\n     */\n    sseDefaultRetryDelay?: number;\n    /**\n     * Maximum number of retry attempts before giving up.\n     */\n    sseMaxRetryAttempts?: number;\n    /**\n     * Maximum retry delay in milliseconds.\n     *\n     * Applies only when exponential backoff is used.\n     *\n     * This option applies only if the endpoint returns a stream of events.\n     *\n     * @default 30000\n     */\n    sseMaxRetryDelay?: number;\n    /**\n     * Optional sleep function for retry backoff.\n     *\n     * Defaults to using `setTimeout`.\n     */\n    sseSleepFn?: (ms: number) => Promise<void>;\n    url: string;\n  };\n\nexport interface StreamEvent<TData = unknown> {\n  data: TData;\n  event?: string;\n  id?: string;\n  retry?: number;\n}\n\nexport type ServerSentEventsResult<\n  TData = unknown,\n  TReturn = void,\n  TNext = unknown,\n> = {\n  stream: AsyncGenerator<\n    TData extends Record<string, unknown> ? TData[keyof TData] : TData,\n    TReturn,\n    TNext\n  >;\n};\n\nexport const createSseClient = <TData = unknown>({\n  onRequest,\n  onSseError,\n  onSseEvent,\n  responseTransformer,\n  responseValidator,\n  sseDefaultRetryDelay,\n  sseMaxRetryAttempts,\n  sseMaxRetryDelay,\n  sseSleepFn,\n  url,\n  ...options\n}: ServerSentEventsOptions): ServerSentEventsResult<TData> => {\n  let lastEventId: string | undefined;\n\n  const sleep =\n    sseSleepFn ??\n    ((ms: number) => new Promise((resolve) => setTimeout(resolve, ms)));\n\n  const createStream = async function* () {\n    let retryDelay: number = sseDefaultRetryDelay ?? 3000;\n    let attempt = 0;\n    const signal = options.signal ?? new AbortController().signal;\n\n    while (true) {\n      if (signal.aborted) break;\n\n      attempt++;\n\n      const headers =\n        options.headers instanceof Headers\n          ? options.headers\n          : new Headers(options.headers as Record<string, string> | undefined);\n\n      if (lastEventId !== undefined) {\n        headers.set('Last-Event-ID', lastEventId);\n      }\n\n      try {\n        const requestInit: RequestInit = {\n          redirect: 'follow',\n          ...options,\n          body: options.serializedBody,\n          headers,\n          signal,\n        };\n        let request = new Request(url, requestInit);\n        if (onRequest) {\n          request = await onRequest(url, requestInit);\n        }\n        // fetch must be assigned here, otherwise it would throw the error:\n        // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n        const _fetch = options.fetch ?? globalThis.fetch;\n        const response = await _fetch(request);\n\n        if (!response.ok)\n          throw new Error(\n            `SSE failed: ${response.status} ${response.statusText}`,\n          );\n\n        if (!response.body) throw new Error('No body in SSE response');\n\n        const reader = response.body\n          .pipeThrough(new TextDecoderStream())\n          .getReader();\n\n        let buffer = '';\n\n        const abortHandler = () => {\n          try {\n            reader.cancel();\n          } catch {\n            // noop\n          }\n        };\n\n        signal.addEventListener('abort', abortHandler);\n\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            buffer += value;\n\n            const chunks = buffer.split('\\n\\n');\n            buffer = chunks.pop() ?? '';\n\n            for (const chunk of chunks) {\n              const lines = chunk.split('\\n');\n              const dataLines: Array<string> = [];\n              let eventName: string | undefined;\n\n              for (const line of lines) {\n                if (line.startsWith('data:')) {\n                  dataLines.push(line.replace(/^data:\\s*/, ''));\n                } else if (line.startsWith('event:')) {\n                  eventName = line.replace(/^event:\\s*/, '');\n                } else if (line.startsWith('id:')) {\n                  lastEventId = line.replace(/^id:\\s*/, '');\n                } else if (line.startsWith('retry:')) {\n                  const parsed = Number.parseInt(\n                    line.replace(/^retry:\\s*/, ''),\n                    10,\n                  );\n                  if (!Number.isNaN(parsed)) {\n                    retryDelay = parsed;\n                  }\n                }\n              }\n\n              let data: unknown;\n              let parsedJson = false;\n\n              if (dataLines.length) {\n                const rawData = dataLines.join('\\n');\n                try {\n                  data = JSON.parse(rawData);\n                  parsedJson = true;\n                } catch {\n                  data = rawData;\n                }\n              }\n\n              if (parsedJson) {\n                if (responseValidator) {\n                  await responseValidator(data);\n                }\n\n                if (responseTransformer) {\n                  data = await responseTransformer(data);\n                }\n              }\n\n              onSseEvent?.({\n                data,\n                event: eventName,\n                id: lastEventId,\n                retry: retryDelay,\n              });\n\n              if (dataLines.length) {\n                yield data as any;\n              }\n            }\n          }\n        } finally {\n          signal.removeEventListener('abort', abortHandler);\n          reader.releaseLock();\n        }\n\n        break; // exit loop on normal completion\n      } catch (error) {\n        // connection failed or aborted; retry after delay\n        onSseError?.(error);\n\n        if (\n          sseMaxRetryAttempts !== undefined &&\n          attempt >= sseMaxRetryAttempts\n        ) {\n          break; // stop after firing error\n        }\n\n        // exponential backoff: double retry each attempt, cap at 30s\n        const backoff = Math.min(\n          retryDelay * 2 ** (attempt - 1),\n          sseMaxRetryDelay ?? 30000,\n        );\n        await sleep(backoff);\n      }\n    }\n  };\n\n  const stream = createStream();\n\n  return { stream };\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\ninterface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { BodySerializer, QuerySerializer } from './bodySerializer.gen';\nimport {\n  type ArraySeparatorStyle,\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from './pathSerializer.gen';\n\nexport interface PathSerializer {\n  path: Record<string, unknown>;\n  url: string;\n}\n\nexport const PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\nexport const defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style: ArraySeparatorStyle = 'simple';\n\n      if (name.endsWith('*')) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n\n      if (name.startsWith('.')) {\n        name = name.substring(1);\n        style = 'label';\n      } else if (name.startsWith(';')) {\n        name = name.substring(1);\n        style = 'matrix';\n      }\n\n      const value = path[name];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        url = url.replace(\n          match,\n          serializeArrayParam({ explode, name, style, value }),\n        );\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        url = url.replace(\n          match,\n          serializeObjectParam({\n            explode,\n            name,\n            style,\n            value: value as Record<string, unknown>,\n            valueOnly: true,\n          }),\n        );\n        continue;\n      }\n\n      if (style === 'matrix') {\n        url = url.replace(\n          match,\n          `;${serializePrimitiveParam({\n            name,\n            value: value as string,\n          })}`,\n        );\n        continue;\n      }\n\n      const replaceValue = encodeURIComponent(\n        style === 'label' ? `.${value as string}` : (value as string),\n      );\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\n\nexport const getUrl = ({\n  baseUrl,\n  path,\n  query,\n  querySerializer,\n  url: _url,\n}: {\n  baseUrl?: string;\n  path?: Record<string, unknown>;\n  query?: Record<string, unknown>;\n  querySerializer: QuerySerializer;\n  url: string;\n}) => {\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\n  let url = (baseUrl ?? '') + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({ path, url });\n  }\n  let search = query ? querySerializer(query) : '';\n  if (search.startsWith('?')) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += `?${search}`;\n  }\n  return url;\n};\n\nexport function getValidRequestBody(options: {\n  body?: unknown;\n  bodySerializer?: BodySerializer | null;\n  serializedBody?: unknown;\n}) {\n  const hasBody = options.body !== undefined;\n  const isSerializedBody = hasBody && options.bodySerializer;\n\n  if (isSerializedBody) {\n    if ('serializedBody' in options) {\n      const hasSerializedBody =\n        options.serializedBody !== undefined && options.serializedBody !== '';\n\n      return hasSerializedBody ? options.serializedBody : null;\n    }\n\n    // not all clients implement a serializedBody property (i.e. client-axios)\n    return options.body !== '' ? options.body : null;\n  }\n\n  // plain/text body\n  if (hasBody) {\n    return options.body;\n  }\n\n  // no body was provided\n  return undefined;\n}\n","// This file is auto-generated by @hey-api/openapi-ts\n\nexport type AuthToken = string | undefined;\n\nexport interface Auth {\n  /**\n   * Which part of the request do we use to send the auth?\n   *\n   * @default 'header'\n   */\n  in?: 'header' | 'query' | 'cookie';\n  /**\n   * Header or query parameter name.\n   *\n   * @default 'Authorization'\n   */\n  name?: string;\n  scheme?: 'basic' | 'bearer';\n  type: 'apiKey' | 'http';\n}\n\nexport const getAuthToken = async (\n  auth: Auth,\n  callback: ((auth: Auth) => Promise<AuthToken> | AuthToken) | AuthToken,\n): Promise<string | undefined> => {\n  const token =\n    typeof callback === 'function' ? await callback(auth) : callback;\n\n  if (!token) {\n    return;\n  }\n\n  if (auth.scheme === 'bearer') {\n    return `Bearer ${token}`;\n  }\n\n  if (auth.scheme === 'basic') {\n    return `Basic ${btoa(token)}`;\n  }\n\n  return token;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport { getAuthToken } from '../core/auth.gen';\nimport type { QuerySerializerOptions } from '../core/bodySerializer.gen';\nimport { jsonBodySerializer } from '../core/bodySerializer.gen';\nimport {\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '../core/pathSerializer.gen';\nimport { getUrl } from '../core/utils.gen';\nimport type { Client, ClientOptions, Config, RequestOptions } from './types.gen';\n\nexport const createQuerySerializer = <T = unknown>({\n  allowReserved,\n  array,\n  object,\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    const search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam({\n            allowReserved,\n            explode: true,\n            name,\n            style: 'form',\n            value,\n            ...array,\n          });\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === 'object') {\n          const serializedObject = serializeObjectParam({\n            allowReserved,\n            explode: true,\n            name,\n            style: 'deepObject',\n            value: value as Record<string, unknown>,\n            ...object,\n          });\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value as string,\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nconst checkForExistence = (\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  },\n  name?: string,\n): boolean => {\n  if (!name) {\n    return false;\n  }\n  if (\n    options.headers.has(name) ||\n    options.query?.[name] ||\n    options.headers.get('Cookie')?.includes(`${name}=`)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    if (checkForExistence(options, auth.name)) {\n      continue;\n    }\n\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) =>\n  getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\n  const entries: Array<[string, string]> = [];\n  headers.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header) {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers\n        ? headersEntries(header)\n        : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  fns: Array<Interceptor | null> = [];\n\n  clear(): void {\n    this.fns = [];\n  }\n\n  eject(id: number | Interceptor): void {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = null;\n    }\n  }\n\n  exists(id: number | Interceptor): boolean {\n    const index = this.getInterceptorIndex(id);\n    return Boolean(this.fns[index]);\n  }\n\n  getInterceptorIndex(id: number | Interceptor): number {\n    if (typeof id === 'number') {\n      return this.fns[id] ? id : -1;\n    }\n    return this.fns.indexOf(id);\n  }\n\n  update(\n    id: number | Interceptor,\n    fn: Interceptor,\n  ): number | Interceptor | false {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = fn;\n      return id;\n    }\n    return false;\n  }\n\n  use(fn: Interceptor): number {\n    this.fns.push(fn);\n    return this.fns.length - 1;\n  }\n}\n\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\n  request: Interceptors<ReqInterceptor<Req, Options>>;\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\n}\n\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\n  Req,\n  Res,\n  Err,\n  Options\n> => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport { createSseClient } from '../core/serverSentEvents.gen';\nimport type { HttpMethod } from '../core/types.gen';\nimport { getValidRequestBody } from '../core/utils.gen';\nimport type {\n  Client,\n  Config,\n  RequestOptions,\n  ResolvedRequestOptions,\n} from './types.gen';\nimport {\n  buildUrl,\n  createConfig,\n  createInterceptors,\n  getParseAs,\n  mergeConfigs,\n  mergeHeaders,\n  setAuthParams,\n} from './utils.gen';\n\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\n  body?: any;\n  headers: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n  let _config = mergeConfigs(createConfig(), config);\n\n  const getConfig = (): Config => ({ ..._config });\n\n  const setConfig = (config: Config): Config => {\n    _config = mergeConfigs(_config, config);\n    return getConfig();\n  };\n\n  const interceptors = createInterceptors<\n    Request,\n    Response,\n    unknown,\n    ResolvedRequestOptions\n  >();\n\n  const beforeRequest = async (options: RequestOptions) => {\n    const opts = {\n      ..._config,\n      ...options,\n      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,\n      headers: mergeHeaders(_config.headers, options.headers),\n      serializedBody: undefined,\n    };\n\n    if (opts.security) {\n      await setAuthParams({\n        ...opts,\n        security: opts.security,\n      });\n    }\n\n    if (opts.requestValidator) {\n      await opts.requestValidator(opts);\n    }\n\n    if (opts.body !== undefined && opts.bodySerializer) {\n      opts.serializedBody = opts.bodySerializer(opts.body);\n    }\n\n    // remove Content-Type header if body is empty to avoid sending invalid requests\n    if (opts.body === undefined || opts.serializedBody === '') {\n      opts.headers.delete('Content-Type');\n    }\n\n    const url = buildUrl(opts);\n\n    return { opts, url };\n  };\n\n  const request: Client['request'] = async (options) => {\n    // @ts-expect-error\n    const { opts, url } = await beforeRequest(options);\n    const requestInit: ReqInit = {\n      redirect: 'follow',\n      ...opts,\n      body: getValidRequestBody(opts),\n    };\n\n    let request = new Request(url, requestInit);\n\n    for (const fn of interceptors.request.fns) {\n      if (fn) {\n        request = await fn(request, opts);\n      }\n    }\n\n    // fetch must be assigned here, otherwise it would throw the error:\n    // TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation\n    const _fetch = opts.fetch!;\n    let response = await _fetch(request);\n\n    for (const fn of interceptors.response.fns) {\n      if (fn) {\n        response = await fn(response, request, opts);\n      }\n    }\n\n    const result = {\n      request,\n      response,\n    };\n\n    if (response.ok) {\n      const parseAs =\n        (opts.parseAs === 'auto'\n          ? getParseAs(response.headers.get('Content-Type'))\n          : opts.parseAs) ?? 'json';\n\n      if (\n        response.status === 204 ||\n        response.headers.get('Content-Length') === '0'\n      ) {\n        let emptyData: any;\n        switch (parseAs) {\n          case 'arrayBuffer':\n          case 'blob':\n          case 'text':\n            emptyData = await response[parseAs]();\n            break;\n          case 'formData':\n            emptyData = new FormData();\n            break;\n          case 'stream':\n            emptyData = response.body;\n            break;\n          case 'json':\n          default:\n            emptyData = {};\n            break;\n        }\n        return opts.responseStyle === 'data'\n          ? emptyData\n          : {\n              data: emptyData,\n              ...result,\n            };\n      }\n\n      let data: any;\n      switch (parseAs) {\n        case 'arrayBuffer':\n        case 'blob':\n        case 'formData':\n        case 'json':\n        case 'text':\n          data = await response[parseAs]();\n          break;\n        case 'stream':\n          return opts.responseStyle === 'data'\n            ? response.body\n            : {\n                data: response.body,\n                ...result,\n              };\n      }\n\n      if (parseAs === 'json') {\n        if (opts.responseValidator) {\n          await opts.responseValidator(data);\n        }\n\n        if (opts.responseTransformer) {\n          data = await opts.responseTransformer(data);\n        }\n      }\n\n      return opts.responseStyle === 'data'\n        ? data\n        : {\n            data,\n            ...result,\n          };\n    }\n\n    const textError = await response.text();\n    let jsonError: unknown;\n\n    try {\n      jsonError = JSON.parse(textError);\n    } catch {\n      // noop\n    }\n\n    const error = jsonError ?? textError;\n    let finalError = error;\n\n    for (const fn of interceptors.error.fns) {\n      if (fn) {\n        finalError = (await fn(error, response, request, opts)) as string;\n      }\n    }\n\n    finalError = finalError || ({} as string);\n\n    if (opts.throwOnError) {\n      throw finalError;\n    }\n\n    // TODO: we probably want to return error and improve types\n    return opts.responseStyle === 'data'\n      ? undefined\n      : {\n          error: finalError,\n          ...result,\n        };\n  };\n\n  const makeMethodFn =\n    (method: Uppercase<HttpMethod>) => (options: RequestOptions) =>\n      request({ ...options, method });\n\n  const makeSseFn =\n    (method: Uppercase<HttpMethod>) => async (options: RequestOptions) => {\n      const { opts, url } = await beforeRequest(options);\n      return createSseClient({\n        ...opts,\n        body: opts.body as BodyInit | null | undefined,\n        headers: opts.headers as unknown as Record<string, string>,\n        method,\n        onRequest: async (url, init) => {\n          let request = new Request(url, init);\n          for (const fn of interceptors.request.fns) {\n            if (fn) {\n              request = await fn(request, opts);\n            }\n          }\n          return request;\n        },\n        url,\n      });\n    };\n\n  return {\n    buildUrl,\n    connect: makeMethodFn('CONNECT'),\n    delete: makeMethodFn('DELETE'),\n    get: makeMethodFn('GET'),\n    getConfig,\n    head: makeMethodFn('HEAD'),\n    interceptors,\n    options: makeMethodFn('OPTIONS'),\n    patch: makeMethodFn('PATCH'),\n    post: makeMethodFn('POST'),\n    put: makeMethodFn('PUT'),\n    request,\n    setConfig,\n    sse: {\n      connect: makeSseFn('CONNECT'),\n      delete: makeSseFn('DELETE'),\n      get: makeSseFn('GET'),\n      head: makeSseFn('HEAD'),\n      options: makeSseFn('OPTIONS'),\n      patch: makeSseFn('PATCH'),\n      post: makeSseFn('POST'),\n      put: makeSseFn('PUT'),\n      trace: makeSseFn('TRACE'),\n    },\n    trace: makeMethodFn('TRACE'),\n  } as Client;\n};\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from './types.gen';\nimport { type ClientOptions as DefaultClientOptions, type Config, createClient, createConfig } from './client';\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> = (override?: Config<DefaultClientOptions & T>) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(createConfig<ClientOptions>({\n    baseUrl: 'https://localhost:44396'\n}));\n"],"names":["serializeFormDataPair","data","key","value","formDataBodySerializer","body","v","jsonBodySerializer","_key","createSseClient","onRequest","onSseError","onSseEvent","responseTransformer","responseValidator","sseDefaultRetryDelay","sseMaxRetryAttempts","sseMaxRetryDelay","sseSleepFn","url","options","lastEventId","sleep","ms","resolve","retryDelay","attempt","signal","headers","requestInit","request","response","reader","buffer","abortHandler","done","chunks","chunk","lines","dataLines","eventName","line","parsed","parsedJson","rawData","error","backoff","separatorArrayExplode","style","separatorArrayNoExplode","separatorObjectExplode","serializeArrayParam","allowReserved","explode","name","joinedValues","separator","serializePrimitiveParam","serializeObjectParam","valueOnly","values","PATH_PARAM_RE","defaultPathSerializer","path","_url","matches","match","replaceValue","getUrl","baseUrl","query","querySerializer","pathUrl","search","getValidRequestBody","hasBody","getAuthToken","auth","callback","token","createQuerySerializer","array","object","queryParams","serializedArray","serializedObject","serializedPrimitive","getParseAs","contentType","cleanContent","type","checkForExistence","setAuthParams","security","buildUrl","mergeConfigs","a","b","config","mergeHeaders","headersEntries","entries","mergedHeaders","header","iterator","Interceptors","id","index","fn","createInterceptors","defaultQuerySerializer","defaultHeaders","createConfig","override","createClient","_config","getConfig","setConfig","interceptors","beforeRequest","opts","_fetch","result","parseAs","emptyData","textError","jsonError","finalError","makeMethodFn","method","makeSseFn","init","client"],"mappings":"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"}